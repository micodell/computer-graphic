<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Parametric Shapes</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #controls { position: absolute; top: 10px; left: 10px; z-index: 10; }
        button { padding: 8px 12px; font-size: 16px; margin-right: 10px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="controls">
        <button id="drawCubeBtn">Draw Cube</button>
        <button id="drawSphereBtn">Draw Sphere</button>
    </div>
    <canvas id="myCanvas"></canvas>

    <!-- Make sure you have downloaded gl-matrix-min.js and placed it here -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>

    <script>
    // --- GEOMETRY GENERATOR FUNCTIONS ---

    function generateCube(width = 1, height = 1, depth = 1) {
        const w = width / 2, h = height / 2, d = depth / 2;
        const vertices = [
            -w, -h, d, w, -h, d, w, h, d, -w, h, d, // Front
            -w, -h, -d, w, -h, -d, w, h, -d, -w, h, -d  // Back
        ];
        const indices = [
            0, 1, 2, 0, 2, 3, 5, 4, 7, 5, 7, 6, 3, 2, 6, 3, 6, 7,
            4, 5, 1, 4, 1, 0, 1, 5, 6, 1, 6, 2, 4, 0, 3, 4, 3, 7
        ];
        // Correcting the vertex array to match the indices
        const fullVertices = [
             -w,-h,d, w,-h,d, w,h,d, -w,h,d, // Front face
             -w,-h,-d, -w,h,-d, w,h,-d, w,-h,-d, // Back face
             -w,h,-d, -w,h,d, w,h,d, w,h,-d, // Top face
             -w,-h,-d, w,-h,-d, w,-h,d, -w,-h,d, // Bottom face
             w,-h,-d, w,h,-d, w,h,d, w,-h,d, // Right face
             -w,-h,-d, -w,-h,d, -w,h,d, -w,h,-d, // Left face
        ];
        const fullIndices = [];
        for(let i=0; i<6; i++){
            let offset = i*4;
            fullIndices.push(offset, offset+1, offset+2, offset, offset+2, offset+3);
        }
        return { vertices: fullVertices, indices: fullIndices };
    }

    function generateSphere(radius = 1, sectorCount = 36, stackCount = 18) {
        const vertices = [];
        const indices = [];
        for (let i = 0; i <= stackCount; ++i) {
            const stackAngle = Math.PI / 2 - i * Math.PI / stackCount;
            const xy = radius * Math.cos(stackAngle);
            const z = radius * Math.sin(stackAngle);
            for (let j = 0; j <= sectorCount; ++j) {
                const sectorAngle = j * 2 * Math.PI / sectorCount;
                const x = xy * Math.cos(sectorAngle);
                const y = xy * Math.sin(sectorAngle);
                vertices.push(x, y, z);
            }
        }
        for (let i = 0; i < stackCount; ++i) {
            let k1 = i * (sectorCount + 1);
            let k2 = k1 + sectorCount + 1;
            for (let j = 0; j < sectorCount; ++j, ++k1, ++k2) {
                if (i !== 0) indices.push(k1, k2, k1 + 1);
                if (i !== (stackCount - 1)) indices.push(k1 + 1, k2, k2 + 1);
            }
        }
        return { vertices, indices };
    }

    // --- WebGL Setup ---
    const canvas = document.getElementById("myCanvas");
    const gl = canvas.getContext("webgl");
    if (!gl) alert("WebGL not supported!");

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);

    // --- Shaders ---
    const vsSource = `
        precision mediump float;
        attribute vec3 aVertexPosition;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        varying vec3 vColor;
        void main(void) {
            gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 1.0);
            vColor = normalize(aVertexPosition) * 0.5 + 0.5;
        }
    `;
    const fsSource = `
        precision mediump float;
        varying vec3 vColor;
        void main(void) {
            gl_FragColor = vec4(vColor, 1.0);
        }
    `;

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Error compiling shader:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    
    function createProgram(gl, vsSource, fsSource) {
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Error linking program:', gl.getProgramInfoLog(program));
            return null;
        }
        return program;
    }

    const shaderProgram = createProgram(gl, vsSource, fsSource);
    gl.useProgram(shaderProgram);

    // --- Shader Locations ---
    const vertexPosAttr = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    const projMatrixUni = gl.getUniformLocation(shaderProgram, "uProjectionMatrix");
    const mvMatrixUni = gl.getUniformLocation(shaderProgram, "uModelViewMatrix");

    // --- Buffers and Geometry Setup ---
    let vbo = gl.createBuffer();
    let ibo = gl.createBuffer();
    let indexCount = 0;

    // This function now takes geometry data and sends it to the GPU
    function setupGeometry(geometry) {
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometry.vertices), gl.STATIC_DRAW);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geometry.indices), gl.STATIC_DRAW);
        
        indexCount = geometry.indices.length;

        gl.vertexAttribPointer(vertexPosAttr, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(vertexPosAttr);
    }
    
    // --- Event Listeners for Buttons ---
    document.getElementById('drawCubeBtn').addEventListener('click', () => {
        const cubeGeometry = generateCube(2.0, 2.0, 2.0); // 2x2x2 cube
        setupGeometry(cubeGeometry);
    });

    document.getElementById('drawSphereBtn').addEventListener('click', () => {
        const sphereGeometry = generateSphere(1.5, 40, 20); // radius 1.5, high detail
        setupGeometry(sphereGeometry);
    });


    // --- Matrices and Render Loop ---
    const projectionMatrix = mat4.create();
    const modelViewMatrix = mat4.create();
    mat4.perspective(projectionMatrix, 45 * Math.PI / 180, canvas.width / canvas.height, 0.1, 100.0);
    gl.uniformMatrix4fv(projMatrixUni, false, projectionMatrix);

    let rotation = 0.0;

    function render() {
        gl.clearColor(0.1, 0.1, 0.15, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.identity(modelViewMatrix);
        mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -7.0]);
        mat4.rotate(modelViewMatrix, modelViewMatrix, rotation, [0.1, 1, 0.3]);
        gl.uniformMatrix4fv(mvMatrixUni, false, modelViewMatrix);
        
        // Draw whatever geometry is currently in the buffers
        if (indexCount > 0) {
            gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);
        }

        rotation += 0.005;
        requestAnimationFrame(render);
    }
    
    // --- Initial Draw ---
    document.getElementById('drawCubeBtn').click(); // Start by drawing a cube
    render(); // Start the render loop

    </script>
</body>
</html>
